# üéØ Pryzor - Previs√£o de Descontos na Steam

> **TCC - Engenharia de Software**  
> Sistema inteligente que prev√™ quando jogos da Steam v√£o entrar em promo√ß√£o

Sabe quando voc√™ fica na d√∫vida se compra um jogo agora ou espera uma promo√ß√£o? O Pryzor resolve isso. Ele analisa o hist√≥rico de pre√ßos da Steam e usa Machine Learning para prever se vale a pena esperar por um desconto melhor.

---

## ü§î O Problema

Todo gamer j√° passou por isso:
- ÔøΩ Comprou um jogo e ele entrou em promo√ß√£o na semana seguinte
- ÔøΩ Ficou esperando um desconto que nunca chegou
- ü§∑ N√£o sabe se o pre√ßo atual √© bom ou se vale esperar

O Pryzor foi criado para acabar com essas d√∫vidas.

---

## üí° A Solu√ß√£o

O sistema funciona assim:

1. **Voc√™ busca o jogo** que quer comprar
2. **O Pryzor analisa** o hist√≥rico de pre√ßos e padr√µes de desconto
3. **O modelo de ML prev√™** se vai ter promo√ß√£o nos pr√≥ximos 30 dias
4. **Voc√™ recebe uma recomenda√ß√£o clara**: "Compre agora" ou "Vale esperar"

Simples, direto e √∫til.

---

## üèóÔ∏è Como Funciona (Arquitetura)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         PRYZOR                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   Frontend   ‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ   Backend    ‚îÇ ‚îÄ‚îÄ‚ñ∂ ‚îÇ   MySQL    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  React + TS  ‚îÇ ‚óÄ‚îÄ‚îÄ‚îÄ ‚îÇ    FastAPI   ‚îÇ ‚óÄ‚îÄ‚îÄ ‚îÇ  Database  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                               ‚îÇ                              ‚îÇ
‚îÇ                               ‚ñº                              ‚îÇ
‚îÇ                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îÇ
‚îÇ                      ‚îÇ  Modelo ML v2.0 ‚îÇ                     ‚îÇ
‚îÇ                      ‚îÇ  Random Forest  ‚îÇ                     ‚îÇ
‚îÇ                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îÇ
‚îÇ                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Componentes:

- **Frontend (React + TypeScript)**: Interface onde voc√™ busca jogos e v√™ as previs√µes
- **Backend (FastAPI)**: API que gerencia dados e faz as previs√µes
- **Banco de Dados (MySQL)**: Armazena 2.000 jogos e 725k registros de pre√ßos hist√≥ricos
- **Modelo ML (Random Forest)**: C√©rebro do sistema, treinado com dados de 2019-2020

---

## üìä O Modelo de Machine Learning

### O que ele faz?

Prev√™ se um jogo vai ter desconto **maior que 20%** nos pr√≥ximos 30 dias.

### Como foi treinado?

Usamos dados reais da Steam (2019-2020) com **valida√ß√£o temporal** - isso significa que o modelo aprendeu com dados do passado e foi testado com dados do futuro, sem "colar" no tempo (evitando data leakage).

### Quais features ele usa?

O modelo analisa 8 coisas sobre o jogo:
- ÔøΩ M√™s do ano e trimestre (sazonalidade)
- ÔøΩ Pre√ßo atual e desconto atual
- üèñÔ∏è Se est√° em per√≠odo de Summer Sale ou Winter Sale
- ÔøΩ Dia da semana e se √© final de semana

### Qu√£o bom ele √©?

| M√©trica | Valor | O que significa? |
|---------|-------|------------------|
| **Precision** | 90.46% | Quando ele diz "vai ter desconto", acerta 9 em 10 vezes |
| **F1-Score** | 74.34% | Balan√ßo geral entre acertos e cobertura |
| **Recall** | 63.09% | Captura 63% dos descontos que realmente acontecem |
| **ROC-AUC** | 79.45% | Capacidade de distinguir entre classes |

**Valida√ß√£o em casos reais:** Testamos o modelo em **1.000 jogos reais** e obtivemos:
- ‚úÖ **92.4% de acur√°cia geral**
- ‚úÖ **97.7% de acerto** quando prev√™ "n√£o ter√° desconto"
- ‚úÖ **Zero casos** de "aguardar" quando o pre√ßo aumentou (Stardew Valley confirmado como caso isolado)

**Por que a Precision √© t√£o alta?**  
Porque priorizamos **confiabilidade**. √â melhor ser conservador e correto do que prometer um desconto que n√£o vai acontecer. Quando o Pryzor diz "espera a√≠ que vai ter promo√ß√£o", voc√™ pode confiar.

**E o Recall moderado (63%)?**  
√â o trade-off. Pegamos 63% das oportunidades de desconto, mas com 90% de certeza de que n√£o √© falso alarme. Para um sistema de recomenda√ß√£o, isso faz sentido.

---

## üî¨ Hist√≥rico de Evolu√ß√£o do Modelo

### üì¶ Modelo v2.0 (ATUAL - EM PRODU√á√ÉO)
**Data:** Outubro 2025  
**Status:** ‚úÖ Est√°vel e validado

**Caracter√≠sticas:**
- 8 features (temporais + contextuais)
- Random Forest (200 estimadores, depth=15)
- Valida√ß√£o temporal (split 2020-04-01)
- Target bin√°rio: desconto >= 20% em 30 dias

**M√©tricas (Teste):**
- Precision: 90.46%
- F1-Score: 74.34%
- Recall: 63.09%
- ROC-AUC: 79.45%

**Valida√ß√£o Real (1.000 jogos):**
- Acur√°cia: 92.4%
- Acerto "Sem desconto": 97.7%
- Zero casos tipo Stardew Valley

**Por que funciona:**  
Modelo conservador e confi√°vel. Prefere n√£o prever desconto quando h√° d√∫vida, o que resulta em alta precision e confian√ßa do usu√°rio.

---

### ‚ùå Modelo v3.0 (DESCARTADO)
**Data:** Outubro 2025  
**Status:** ‚õî Rejeitado - Performance inferior ao v2.0

**O que tentamos:**
- Target multi-classe (4 categorias: price_increase, stable, small_discount, large_discount)
- Objetivo: Distinguir aumentos de pre√ßo vs estabilidade
- Motiva√ß√£o: Resolver caso Stardew Valley

**Resultado:**
- ‚ùå F1-Score: ~45% (vs 74% do v2.0)
- ‚ùå Precision caiu drasticamente
- ‚ùå Complexidade adicional sem ganho pr√°tico
- ‚ùå ROC-AUC: 74.2% (vs 79.45% do v2.0)

**Li√ß√£o aprendida:**  
Multi-classe n√£o funciona bem com dados desbalanceados. O caso Stardew Valley (pre√ßo aumentou ap√≥s promo√ß√£o) √© EXTREMAMENTE RARO (0.3% dos casos). N√£o vale adicionar complexidade para resolver 3 casos em 1000.

**Decis√£o:** Reverter para v2.0. A abordagem bin√°ria simples funciona melhor.

---

### ‚ùå Modelo v2.1 (DESCARTADO)
**Data:** Outubro 2025  
**Status:** ‚õî Rejeitado - Piora significativa

**O que tentamos:**
- Adicionar 3 features de dura√ß√£o de promo√ß√£o:
  - `discount_consecutive_days`: Dias em promo√ß√£o
  - `discount_progress_ratio`: Progresso da promo√ß√£o
  - `discount_likely_ending`: Booleano se est√° terminando
- Objetivo: Melhorar detec√ß√£o de descontos cont√≠nuos
- Motiva√ß√£o: 53 de 76 erros eram em jogos com desconto ativo

**Resultado:**
- ‚ùå **F1-Score: 38.11%** (vs 74.34% do v2.0) - QUEDA DE 36%!
- ‚ùå Precision: 25.67% (vs 90.46%) - DESTRU√çDA
- ‚úÖ Recall: 73.97% (vs 63.09%) - Aumentou, mas...
- ‚ùå ROC-AUC: 73.71% (vs 79.45%)

**O que deu errado:**  
As features de dura√ß√£o fizeram o modelo ficar "ansioso demais". Ele passou a prever desconto em TUDO, gerando uma avalanche de falsos positivos. A precision caiu de 90% para 26% - inaceit√°vel para um sistema de recomenda√ß√£o.

**An√°lise de import√¢ncia:**
- `discount_consecutive_days` ficou em 3¬∫ lugar (10.55% de import√¢ncia)
- Mas causou desbalanceamento severo
- Modelo aprendeu: "tem desconto h√° X dias ‚Üí vai continuar sempre"

**Li√ß√£o aprendida:**  
Features de dura√ß√£o s√£o √∫teis em TEORIA, mas na PR√ÅTICA causam overfitting em padr√µes espec√≠ficos. O modelo v2.0 simples generaliza melhor.

**Decis√£o:** Reverter para v2.0. Simplicidade vence complexidade.

---

## üí° Conclus√£o do Processo Iterativo

Ap√≥s 3 itera√ß√µes (v2.0 ‚Üí v3.0 ‚Üí v2.1), confirmamos que:

1. **Simplicidade funciona** - 8 features bem escolhidas > 11 features complexas
2. **Bin√°rio > Multi-classe** - Para dados desbalanceados, menos √© mais
3. **Precision > Recall** - Em sistemas de recomenda√ß√£o, confiabilidade √© rei
4. **Casos raros n√£o justificam complexidade** - Stardew Valley (0.3%) n√£o vale reformular tudo
5. **Valida√ß√£o real √© essencial** - Testar em 1.000 jogos revelou que v2.0 j√° √© excelente

**Modelo v2.0 permanece em produ√ß√£o** ‚úÖ

---

## üéØ Pr√≥ximos Passos (Futuro)

Se quisermos melhorar o v2.0 no futuro, as abordagens promissoras s√£o:

1. **Regras de neg√≥cio h√≠bridas** - v2.0 + regra simples p√≥s-predi√ß√£o
2. **Mais dados temporais** - Expandir dataset 2020-2023
3. **Features de frequ√™ncia** - Quantas vezes o jogo entra em promo√ß√£o por ano
4. **Ensemble conservador** - Combinar v2.0 com modelo secund√°rio (s√≥ para confirmar)

Mas por enquanto, **v2.0 est√° excelente e est√°vel**.

---

## üöÄ Como Rodar o Projeto

### Op√ß√£o 1: Rodar s√≥ o backend (API + ML)

```bash
# 1. Entre na pasta do backend
cd pryzor-back

# 2. Crie um ambiente virtual
python -m venv venv
venv\Scripts\activate  # Windows
source venv/bin/activate  # Mac/Linux

# 3. Instale as depend√™ncias
pip install -r requirements.txt

# 4. Configure o banco de dados (crie um .env)
# Copie o .env.example e preencha com seus dados MySQL

# 5. Rode a API
python src/main.py
```

Acesse: `http://localhost:8000/docs` para ver a documenta√ß√£o interativa.

### Op√ß√£o 2: Rodar o projeto completo (Backend + Frontend)

```bash
# Terminal 1: Backend
cd pryzor-back
python src/main.py

# Terminal 2: Frontend
cd pryzor-front
npm install
npm run dev
```

Acesse: `http://localhost:5173` para usar a interface.

---

## üì° Endpoints Principais da API

### Sistema
- `GET /health` - Verifica se tudo est√° funcionando
- `GET /api/stats` - Estat√≠sticas gerais (quantos jogos, registros, etc)

### Jogos
- `GET /api/games` - Lista jogos (com filtros e pagina√ß√£o)
- `GET /api/games/{appid}` - Detalhes de um jogo espec√≠fico
- `GET /api/games?search=Counter` - Busca jogos por nome

### Machine Learning
- `GET /api/ml/info` - Informa√ß√µes sobre o modelo (vers√£o, m√©tricas)
- `GET /api/ml/predict/730` - Faz previs√£o para um jogo (ex: CS:GO)
- `POST /api/ml/predict/batch` - Previs√£o em lote (at√© 50 jogos)

**Exemplo de resposta:**
```json
{
  "appid": 271590,
  "game_name": "Grand Theft Auto V",
  "will_have_discount": true,
  "probability": 0.78,
  "confidence": 0.56,
  "recommendation": "AGUARDAR - Alta probabilidade de desconto melhor em breve",
  "current_price": 119.90
}
```

---

## üõ†Ô∏è Tecnologias Usadas

### Backend
- **Python 3.11** - Linguagem principal
- **FastAPI** - Framework web (r√°pido e moderno)
- **scikit-learn** - Machine Learning
- **pandas** - Manipula√ß√£o de dados
- **MySQL** - Banco de dados (2.000 jogos, 725k registros)

### Frontend
- **React 19** - Framework de interface
- **TypeScript** - JavaScript com tipos
- **Vite** - Build tool (super r√°pido)
- **Axios** - Cliente HTTP

### Machine Learning
- **Random Forest** - Algoritmo de classifica√ß√£o
- **Valida√ß√£o Temporal** - Split antes/depois de 2020-04-01
- **8 Features** - Temporais e contextuais (sem data leakage)

---

## üìÅ Estrutura do Reposit√≥rio

```
pryzor/
‚îú‚îÄ‚îÄ pryzor-back/              # Backend (API + ML)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py           # API FastAPI (11 endpoints)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/              # Servi√ßos (ML, schemas)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database/         # Conex√£o MySQL
‚îÇ   ‚îú‚îÄ‚îÄ scripts/              # Scripts de treinamento
‚îÇ   ‚îú‚îÄ‚îÄ ml_model/             # Modelo treinado (.pkl)
‚îÇ   ‚îú‚îÄ‚îÄ tests/                # Testes automatizados
‚îÇ   ‚îî‚îÄ‚îÄ docs/                 # Documenta√ß√£o t√©cnica
‚îÇ
‚îú‚îÄ‚îÄ pryzor-front/             # Frontend (React)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/       # Componentes React
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/         # Cliente API
‚îÇ   ‚îî‚îÄ‚îÄ public/
‚îÇ
‚îú‚îÄ‚îÄ CONTEXT.md                # Contexto completo do projeto
‚îú‚îÄ‚îÄ COPILOT_PROMPT.md         # Prompt para continuar desenvolvimento
‚îî‚îÄ‚îÄ README.md                 # Este arquivo
```

---

## üéì Contexto Acad√™mico (TCC)

Este projeto foi desenvolvido como Trabalho de Conclus√£o de Curso em Engenharia de Software.

### Diferenciais t√©cnicos:

‚úÖ **Valida√ß√£o temporal adequada** - Corrigimos data leakage, uma armadilha comum em s√©ries temporais  
‚úÖ **Pipeline completo** - ETL, feature engineering, treinamento, valida√ß√£o, deploy  
‚úÖ **API RESTful funcional** - 11 endpoints testados e documentados  
‚úÖ **C√≥digo limpo** - Organizado, comentado, testado  
‚úÖ **Documenta√ß√£o completa** - README, docs t√©cnicos, coment√°rios  

### O que o projeto demonstra:

- üß† **Machine Learning aplicado** - N√£o √© s√≥ teoria, funciona de verdade
- üîß **Engenharia de Software** - Arquitetura limpa, c√≥digo test√°vel
- üìä **An√°lise de dados** - ETL, feature engineering, valida√ß√£o
- üåê **Desenvolvimento Full-Stack** - Backend + Frontend integrados
- üìö **Rigor acad√™mico** - Metodologia, documenta√ß√£o, reprodutibilidade

---

## üìù Licen√ßa

Este projeto √© acad√™mico e foi desenvolvido para fins de aprendizado.

---

## ÔøΩ Autor

**Gustavo Peruci**  
üìß [Seu email]  
üîó [GitHub](https://github.com/GustaPeruci)  
üéì TCC - Engenharia de Software - 2025

---

**üí° Dica:** Para mais detalhes t√©cnicos sobre o backend ou frontend, veja os READMEs espec√≠ficos em `pryzor-back/README.md` e `pryzor-front/README.md`.